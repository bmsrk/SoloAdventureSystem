@page "/worlds"
@rendermode InteractiveServer
@using System.IO
@using System.IO.Compression
@using System.Text.Json
@inject NavigationManager Navigation
@inject IJSRuntime JS
@inject SoloAdventureSystem.Web.UI.Services.WorldFileValidator FileValidator

<PageTitle>Manage Worlds</PageTitle>

<div class="mud-worlds">
    <div class="mud-header">
        <div class="header-left">
            <h1 class="mud-title">Worlds</h1>
            <p class="mud-sub">Manage your generated worlds</p>
        </div>
        <div class="header-right">
            <Button Class="mud-link" OnClick='@(() => Navigation.NavigateTo("/generate"))'>Generate New</Button>
        </div>
    </div>

    @if (isLoading)
    {
        <div class="empty-state">
            <div class="empty-icon">[ ]</div>
            <h2 class="empty-title">Scanning...</h2>
            <p class="empty-description">Looking for world archives on disk.</p>
        </div>
    }
    else if (worlds.Count == 0)
    {
        <div class="empty-state">
            <div class="empty-icon">[ ]</div>
            <h2 class="empty-title">No Worlds Yet</h2>
            <p class="empty-description">You haven't generated any worlds yet. Create one to get started.</p>
            <Button Class="mud-btn" OnClick='@(() => Navigation.NavigateTo("/generate"))'>Generate World</Button>
        </div>
    }
    else
    {
        <div class="stats-row">
            <div class="stat">Worlds: <strong>@worlds.Count</strong></div>
            <div class="stat">Total size: <strong>@FormatBytes(totalSize)</strong></div>
        </div>

        <div class="worlds-list">
            @foreach (var world in GetSortedWorlds())
            {
                <div class="world-item">
                    <div class="world-left">
                        <div class="world-icon">@world.Name.Substring(0, 1).ToUpper()</div>
                        <div>
                            <div class="world-name">@world.Name</div>
                            <div class="world-meta">@world.CreatedDate.ToString("MMM dd, yyyy") • @FormatBytes(world.FileSize)</div>
                        </div>
                    </div>

                    <div class="world-right">
                        <div class="badges">
                            @if (world.Validation != null)
                            {
                                var stateClass = world.Validation.OverallScore >= 80 ? "good" : world.Validation.OverallScore >= 50 ? "warn" : "bad";
                                <span class="badge @stateClass">Score: @world.Validation.OverallScore</span>
                            }
                            else
                            {
                                <span class="badge neutral">Not validated</span>
                            }
                        </div>

                        <div class="actions">
                            <Button Class="mud-action" OnClick='@(() => ViewWorld(world))'>View</Button>
                            <Button Class="mud-action" OnClick='@(() => PlayGame(world))'>Play</Button>
                            <Button Class="mud-action" OnClick='@(() => CopyPath(world))'>Copy</Button>
                            <Button Class="mud-action" OnClick='@(() => RunValidation(world))'>Validate</Button>
                            <Button Class="mud-action danger" OnClick='@(() => ConfirmDelete(world))'>Delete</Button>
                        </div>
                    </div>
                </div>
            }
        </div>

        <div class="batch-row">
            <Button Class="mud-btn" OnClick='@(() => RunBatchValidation())'>Validate All Worlds</Button>
        </div>
    }
</div>

<!-- Delete Confirmation Modal -->
@if (showDeleteDialog && worldToDelete != null)
{
    <div class="modal-overlay">
        <div class="modal-box">
            <div class="modal-title">Confirm Deletion</div>
            <div class="modal-body">Delete <strong>@worldToDelete.Name</strong>? This cannot be undone.</div>
            <div class="modal-actions">
                <Button Class="mud-btn" OnClick='@(() => CancelDelete())'>Cancel</Button>
                <Button Class="mud-btn danger" OnClick='@(() => ConfirmDeleteWorld())'>Delete</Button>
            </div>
        </div>
    </div>
}

@if (!string.IsNullOrEmpty(successMessage))
{
    <div class="toast">@successMessage</div>
}

<style>
.mud-worlds { max-width: 1100px; margin: 2rem auto; padding: 1rem; font-family: 'Courier New', monospace; color: #9fffe0; }
.mud-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:1rem; }
.mud-title { margin:0; font-size:1.5rem; color:#00ffcc; }
.mud-sub { margin:0; color:#6fe6c9; font-size:0.95rem }
.mud-link { color:#00ffcc; text-decoration:none; border:1px solid #004d40; padding:0.4rem 0.6rem; border-radius:6px }
.stats-row { display:flex; gap:1.5rem; margin-bottom:1rem; color:#9ca3af }
.worlds-list { display:flex; flex-direction:column; gap:0.6rem }
.world-item { display:flex; justify-content:space-between; align-items:center; padding:0.8rem; background:#030303; border:1px solid rgba(0,255,255,0.06); border-radius:8px }
.world-left { display:flex; gap:0.75rem; align-items:center }
.world-icon { width:48px; height:48px; background:#00121a; display:flex; align-items:center; justify-content:center; border-radius:6px; color:#7fffd4; font-weight:700 }
.world-name { font-weight:700; color:#ffffff }
.world-meta { color:#6fe6c9; font-size:0.85rem }
.world-right { display:flex; gap:1rem; align-items:center }
.badge { padding:0.25rem 0.5rem; border-radius:6px; font-size:0.85rem }
.badge.good { background:#042f16; color:#7fffd4 }
.badge.warn { background:#2f2a00; color:#ffd36b }
.badge.bad { background:#3a0f0f; color:#ff9b9b }
.badge.neutral { background:transparent; border:1px solid rgba(159,255,224,0.06); color:#9fffe0 }
.actions { display:flex; gap:0.5rem }
.mud-action { background:#00121a; color:#7fffd4; border:1px solid rgba(0,77,64,0.2); padding:0.4rem 0.6rem; border-radius:6px; cursor:pointer }
.mud-action.danger { background:#220707; color:#ffb3b3 }
.mud-btn { background:#00121a; color:#7fffd4; border:1px solid #004d40; padding:0.5rem 0.8rem; border-radius:6px; cursor:pointer }
.batch-row { display:flex; justify-content:center; margin-top:1rem }
.empty-state { text-align:center; padding:3rem; color:#9ca3af }
.empty-icon { font-size:3rem; color:#6fe6c9 }
.toast { position:fixed; right:1rem; bottom:1rem; background:#002522; color:#9fffe0; padding:0.6rem 1rem; border-radius:6px }
.modal-overlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.6) }
.modal-box { background:#0a0a0a; padding:1rem 1.25rem; border-radius:8px; border:1px solid rgba(0,255,255,0.06); width:320px }
.modal-title { font-weight:700; margin-bottom:0.5rem; color:#00ffcc }
.modal-body { color:#9ca3af; margin-bottom:1rem }
.modal-actions { display:flex; justify-content:flex-end; gap:0.5rem }
</style>

@code {
    private List<WorldInfo> worlds = new();
    private bool isLoading = true;
    private long totalSize = 0;
    private string sortBy = "date-desc";
    private bool showDeleteDialog = false;
    private WorldInfo? worldToDelete = null;
    private string successMessage = "";

    protected override async Task OnInitializedAsync()
    {
        await LoadWorlds();
    }

    private async Task LoadWorlds()
    {
        isLoading = true;
        worlds.Clear();
        totalSize = 0;
        try
        {
            var worldsPath = GetWorldsDirectory();
            if (Directory.Exists(worldsPath))
            {
                var files = Directory.GetFiles(worldsPath, "*.zip");
                foreach (var file in files)
                {
                    var info = await LoadWorldInfo(file);
                    if (info != null)
                    {
                        var valPath = file + ".validation.json";
                        if (File.Exists(valPath))
                        {
                            try
                            {
                                var json = await File.ReadAllTextAsync(valPath);
                                var val = JsonSerializer.Deserialize<SoloAdventureSystem.Web.UI.Services.WorldValidationResult>(json, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                                info.Validation = val;
                            }
                            catch { }
                        }

                        worlds.Add(info);
                        totalSize += info.FileSize;
                    }
                }
            }
        }
        catch { }
        finally { isLoading = false; }
    }

    private async Task<WorldInfo?> LoadWorldInfo(string filePath)
    {
        try
        {
            var fi = new FileInfo(filePath);
            var name = Path.GetFileNameWithoutExtension(filePath);
            var stats = new WorldStats { Rooms = 0, NPCs = 0, Factions = 0, Lore = 0 };
            try
            {
                using var zip = ZipFile.OpenRead(filePath);
                stats.Rooms = zip.Entries.Count(e => e.FullName.StartsWith("rooms/") && e.FullName.EndsWith(".json"));
                stats.NPCs = zip.Entries.Count(e => e.FullName.StartsWith("npcs/") && e.FullName.EndsWith(".json"));
                stats.Factions = zip.Entries.Count(e => e.FullName.StartsWith("factions/") && e.FullName.EndsWith(".json"));
            }
            catch { }

            return new WorldInfo { Name = name, Id = name, FilePath = filePath, FileName = fi.Name, FileSize = fi.Length, CreatedDate = fi.CreationTime, ModifiedDate = fi.LastWriteTime, Stats = stats };
        }
        catch { return null; }
    }

    private IEnumerable<WorldInfo> GetSortedWorlds()
    {
        return sortBy switch
        {
            "date-desc" => worlds.OrderByDescending(w => w.CreatedDate),
            "date-asc" => worlds.OrderBy(w => w.CreatedDate),
            "name-asc" => worlds.OrderBy(w => w.Name),
            "name-desc" => worlds.OrderByDescending(w => w.Name),
            "size-desc" => worlds.OrderByDescending(w => w.FileSize),
            "size-asc" => worlds.OrderBy(w => w.FileSize),
            _ => worlds.OrderByDescending(w => w.CreatedDate)
        };
    }

    private void ViewWorld(WorldInfo world) { Navigation.NavigateTo($"/worlds/{Uri.EscapeDataString(world.Id)}"); }
    private void PlayGame(WorldInfo world) { Navigation.NavigateTo($"/game/{Uri.EscapeDataString(world.Id)}"); }
    private async Task CopyPath(WorldInfo world) { await JS.InvokeVoidAsync("navigator.clipboard.writeText", world.FilePath); ShowSuccess("Path copied to clipboard!"); }

    private void ConfirmDelete(WorldInfo world) { worldToDelete = world; showDeleteDialog = true; }
    private void CancelDelete() { worldToDelete = null; showDeleteDialog = false; }
    private async Task ConfirmDeleteWorld() { if (worldToDelete == null) return; try { File.Delete(worldToDelete.FilePath); ShowSuccess($"Deleted {worldToDelete.Name}"); showDeleteDialog = false; worldToDelete = null; await LoadWorlds(); } catch { } }

    private async Task RunValidation(WorldInfo world)
    {
        try
        {
            ShowSuccess($"Running validation for {world.Name}...");
            var result = await FileValidator.ValidateWorldFileWithQualityAsync(world.FilePath);
            world.Validation = result;
            await LoadWorlds();
            ShowSuccess($"Validation complete: {result.OverallScore}");
        }
        catch (Exception ex)
        {
            ShowSuccess($"Validation failed: {ex.Message}");
        }
    }

    private async Task RunBatchValidation()
    {
        try
        {
            ShowSuccess("Running batch validation...");
            var results = await FileValidator.BatchValidateWorldsAsync(GetWorldsDirectory());
            await LoadWorlds();
            var validCount = results.Count(r => r.Errors.Count == 0);
            var avgScore = results.Where(r => r.Errors.Count == 0).Average(r => r.OverallScore);
            ShowSuccess($"Batch validation complete: {validCount}/{results.Count} worlds valid, Avg Score: {avgScore:F1}");
        }
        catch (Exception ex)
        {
            ShowSuccess($"Batch validation failed: {ex.Message}");
        }
    }

    private async void ShowSuccess(string message)
    {
        successMessage = message; StateHasChanged(); await Task.Delay(3000); successMessage = ""; StateHasChanged();
    }

    private string GetWorldsDirectory()
    {
        return Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), "source", "repos", "SoloAdventureSystem", "content", "worlds");
    }

    private string FormatBytes(long bytes) { string[] sizes = { "B", "KB", "MB", "GB" }; double len = bytes; int order = 0; while (len >= 1024 && order < sizes.Length - 1) { order++; len /= 1024; } return $"{len:0.##} {sizes[order]}"; }

    private class WorldInfo { public string Name { get; set; } = ""; public string Id { get; set; } = ""; public string FilePath { get; set; } = ""; public string FileName { get; set; } = ""; public long FileSize { get; set; } public DateTime CreatedDate { get; set; } public DateTime ModifiedDate { get; set; } public WorldStats? Stats { get; set; } public SoloAdventureSystem.Web.UI.Services.WorldValidationResult? Validation { get; set; } }
    private class WorldStats { public int Rooms { get; set; } public int NPCs { get; set; } public int Factions { get; set; } public int Lore { get; set; } }
}
